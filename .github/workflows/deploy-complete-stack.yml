name: üöÄ Deploy Complete MLOps Stack to EKS

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'production'
        type: choice
        options:
        - production
        - staging
      api_image_tag:
        description: 'FastAPI Docker image tag'
        required: false
        default: 'latest'
      ui_image_tag:
        description: 'UI Docker image tag'
        required: false
        default: 'latest'
      skip_api:
        description: 'Skip FastAPI deployment'
        required: false
        default: false
        type: boolean
      skip_ui:
        description: 'Skip UI deployment'
        required: false
        default: false
        type: boolean

env:
  AWS_REGION: ap-south-1
  ECR_REPOSITORY_API: churn-prediction-api
  ECR_REPOSITORY_UI: churn-prediction-ui
  EKS_CLUSTER_NAME: churnmodel

jobs:
  deploy-complete-stack:
    name: üöÄ Deploy Complete MLOps Stack
    runs-on: ubuntu-latest
    
    steps:
    - name: üì• Checkout Repository
      uses: actions/checkout@v4
      
    - name: üîê Configure AWS Credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
        
    - name: üì¶ Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v2
      
    - name: ‚öôÔ∏è Configure kubectl
      run: |
        aws eks update-kubeconfig --region ${{ env.AWS_REGION }} --name ${{ env.EKS_CLUSTER_NAME }}
        kubectl version --client
        echo "‚úÖ kubectl configured for EKS cluster: ${{ env.EKS_CLUSTER_NAME }}"
        
    - name: üîç Create ECR Repositories
      run: |
        # Create API repository
        aws ecr describe-repositories --repository-names ${{ env.ECR_REPOSITORY_API }} || \
        aws ecr create-repository --repository-name ${{ env.ECR_REPOSITORY_API }}
        
        # Create UI repository
        aws ecr describe-repositories --repository-names ${{ env.ECR_REPOSITORY_UI }} || \
        aws ecr create-repository --repository-name ${{ env.ECR_REPOSITORY_UI }}
        
        echo "‚úÖ ECR repositories verified/created"
        
    # FastAPI Deployment
    - name: üîß Deploy FastAPI Backend
      if: ${{ !github.event.inputs.skip_api }}
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        IMAGE_TAG: ${{ github.event.inputs.api_image_tag || 'latest' }}
      run: |
        echo "üîß Starting FastAPI deployment..."
        
        # Build FastAPI image
        cd fastapi-deployment/
        echo "üî® Building FastAPI Docker image..."
        docker build -t $ECR_REGISTRY/$ECR_REPOSITORY_API:$IMAGE_TAG \
                     -t $ECR_REGISTRY/$ECR_REPOSITORY_API:${{ github.sha }} \
                     -t $ECR_REGISTRY/$ECR_REPOSITORY_API:latest .
        
        # Test API image
        echo "üß™ Testing FastAPI image..."
        docker run --rm -d --name test-api -p 8000:8000 \
          $ECR_REGISTRY/$ECR_REPOSITORY_API:$IMAGE_TAG
        sleep 15
        
        if curl -f http://localhost:8000/health; then
          echo "‚úÖ FastAPI health check passed"
        else
          echo "‚ùå FastAPI health check failed"
          docker logs test-api
          exit 1
        fi
        docker stop test-api
        
        # Push API image
        echo "üì§ Pushing FastAPI images..."
        docker push $ECR_REGISTRY/$ECR_REPOSITORY_API:$IMAGE_TAG
        docker push $ECR_REGISTRY/$ECR_REPOSITORY_API:${{ github.sha }}
        docker push $ECR_REGISTRY/$ECR_REPOSITORY_API:latest
        
        # Create AWS credentials secret
        kubectl delete secret aws-credentials --ignore-not-found=true
        kubectl create secret generic aws-credentials \
          --from-literal=aws-access-key-id=${{ secrets.AWS_ACCESS_KEY_ID }} \
          --from-literal=aws-secret-access-key=${{ secrets.AWS_SECRET_ACCESS_KEY }}
        
        # Update Kubernetes manifests
        sed -i "s|image: churn-prediction-api:latest|image: $ECR_REGISTRY/$ECR_REPOSITORY_API:$IMAGE_TAG|g" k8s-deployment.yaml
        
        # Deploy to EKS
        echo "üöÄ Deploying FastAPI to EKS..."
        kubectl apply -f k8s-deployment.yaml
        kubectl rollout status deployment/churn-prediction-api --timeout=300s
        
        echo "‚úÖ FastAPI deployment completed!"
        
    - name: üîç Get FastAPI URL
      id: get-api-url
      run: |
        # Wait for API service to be ready
        sleep 10
        
        NODE_PORT=$(kubectl get service churn-prediction-api-nodeport -o jsonpath='{.spec.ports[0].nodePort}' 2>/dev/null || echo "30080")
        NODE_IP=$(kubectl get nodes -o jsonpath='{.items[0].status.addresses[?(@.type=="ExternalIP")].address}' 2>/dev/null)
        
        if [ -n "$NODE_IP" ]; then
          API_URL="http://$NODE_IP:$NODE_PORT"
        else
          API_URL="http://NODE_IP:30080"
        fi
        
        echo "api_url=$API_URL" >> $GITHUB_OUTPUT
        echo "üîó FastAPI URL: $API_URL"
        
    # UI Deployment
    - name: üé® Deploy UI Frontend
      if: ${{ !github.event.inputs.skip_ui }}
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        IMAGE_TAG: ${{ github.event.inputs.ui_image_tag || 'latest' }}
        API_URL: ${{ steps.get-api-url.outputs.api_url }}
      run: |
        echo "üé® Starting UI deployment..."
        
        # Update API configuration in UI
        cd ui-deployment/
        echo "üîß Updating API URL to: $API_URL"
        sed -i "s|http://NODE_IP:30080|$API_URL|g" script.js
        
        # Build UI image
        echo "üî® Building UI Docker image..."
        docker build -t $ECR_REGISTRY/$ECR_REPOSITORY_UI:$IMAGE_TAG \
                     -t $ECR_REGISTRY/$ECR_REPOSITORY_UI:${{ github.sha }} \
                     -t $ECR_REGISTRY/$ECR_REPOSITORY_UI:latest .
        
        # Test UI image
        echo "üß™ Testing UI image..."
        docker run --rm -d --name test-ui -p 3000:80 \
          $ECR_REGISTRY/$ECR_REPOSITORY_UI:$IMAGE_TAG
        sleep 10
        
        if curl -f http://localhost:3000/health; then
          echo "‚úÖ UI health check passed"
        else
          echo "‚ùå UI health check failed"
          docker logs test-ui
          exit 1
        fi
        
        if curl -f http://localhost:3000/ | grep -q "Customer Churn"; then
          echo "‚úÖ UI main page loads correctly"
        else
          echo "‚ùå UI main page test failed"
          docker logs test-ui
          exit 1
        fi
        docker stop test-ui
        
        # Push UI image
        echo "üì§ Pushing UI images..."
        docker push $ECR_REGISTRY/$ECR_REPOSITORY_UI:$IMAGE_TAG
        docker push $ECR_REGISTRY/$ECR_REPOSITORY_UI:${{ github.sha }}
        docker push $ECR_REGISTRY/$ECR_REPOSITORY_UI:latest
        
        # Update Kubernetes manifests
        sed -i "s|image: churn-prediction-ui:latest|image: $ECR_REGISTRY/$ECR_REPOSITORY_UI:$IMAGE_TAG|g" k8s-deployment.yaml
        
        # Deploy to EKS
        echo "üöÄ Deploying UI to EKS..."
        kubectl apply -f k8s-deployment.yaml
        kubectl rollout status deployment/churn-prediction-ui --timeout=300s
        
        echo "‚úÖ UI deployment completed!"
        
    - name: üîç Verify Complete Deployment
      run: |
        echo "üîç Verifying complete stack deployment..."
        
        # Check all pods
        echo "üì¶ Checking pods..."
        kubectl get pods -l tier=backend
        kubectl get pods -l tier=frontend
        
        # Check all services
        echo "üåê Checking services..."
        kubectl get services -l app=churn-prediction-api
        kubectl get services -l app=churn-prediction-ui
        
        # Get URLs
        API_PORT=$(kubectl get service churn-prediction-api-nodeport -o jsonpath='{.spec.ports[0].nodePort}' 2>/dev/null || echo "30080")
        UI_PORT=$(kubectl get service churn-prediction-ui-nodeport -o jsonpath='{.spec.ports[0].nodePort}' 2>/dev/null || echo "30081")
        NODE_IP=$(kubectl get nodes -o jsonpath='{.items[0].status.addresses[?(@.type=="ExternalIP")].address}' 2>/dev/null || echo "NODE_IP")
        
        echo "üîó Service URLs:"
        echo "  FastAPI: http://$NODE_IP:$API_PORT"
        echo "  UI: http://$NODE_IP:$UI_PORT"
        echo "  API Docs: http://$NODE_IP:$API_PORT/docs"
        
    - name: üß™ End-to-End Health Check
      run: |
        echo "üß™ Running end-to-end health checks..."
        
        # Wait for services to be fully ready
        sleep 30
        
        API_PORT=$(kubectl get service churn-prediction-api-nodeport -o jsonpath='{.spec.ports[0].nodePort}' 2>/dev/null || echo "30080")
        UI_PORT=$(kubectl get service churn-prediction-ui-nodeport -o jsonpath='{.spec.ports[0].nodePort}' 2>/dev/null || echo "30081")
        NODE_IP=$(kubectl get nodes -o jsonpath='{.items[0].status.addresses[?(@.type=="ExternalIP")].address}' 2>/dev/null)
        
        if [ -n "$NODE_IP" ]; then
          echo "üîç Testing FastAPI health..."
          if curl -f "http://$NODE_IP:$API_PORT/health"; then
            echo "‚úÖ FastAPI health check passed"
          else
            echo "‚ö†Ô∏è FastAPI health check failed"
          fi
          
          echo "üîç Testing UI health..."
          if curl -f "http://$NODE_IP:$UI_PORT/health"; then
            echo "‚úÖ UI health check passed"
          else
            echo "‚ö†Ô∏è UI health check failed"
          fi
          
          echo "üîç Testing API-UI connectivity..."
          if curl -f "http://$NODE_IP:$API_PORT/model-info"; then
            echo "‚úÖ API model endpoint accessible"
          else
            echo "‚ö†Ô∏è API model endpoint not accessible"
          fi
        else
          echo "‚ö†Ô∏è External IP not available, using port-forward for testing..."
          kubectl port-forward service/churn-prediction-api-service 8000:80 &
          kubectl port-forward service/churn-prediction-ui-service 3000:80 &
          sleep 5
          
          curl -f http://localhost:8000/health && echo "‚úÖ API accessible via port-forward"
          curl -f http://localhost:3000/health && echo "‚úÖ UI accessible via port-forward"
          
          pkill -f "kubectl port-forward" || true
        fi
        
    - name: üìä Complete Stack Summary
      run: |
        API_PORT=$(kubectl get service churn-prediction-api-nodeport -o jsonpath='{.spec.ports[0].nodePort}' 2>/dev/null || echo "30080")
        UI_PORT=$(kubectl get service churn-prediction-ui-nodeport -o jsonpath='{.spec.ports[0].nodePort}' 2>/dev/null || echo "30081")
        
        echo "## üéâ Complete MLOps Stack Deployment Summary" >> $GITHUB_STEP_SUMMARY
        echo "| Component | Status | Port |" >> $GITHUB_STEP_SUMMARY
        echo "|-----------|--------|------|" >> $GITHUB_STEP_SUMMARY
        echo "| FastAPI Backend | ‚úÖ Deployed | $API_PORT |" >> $GITHUB_STEP_SUMMARY
        echo "| UI Frontend | ‚úÖ Deployed | $UI_PORT |" >> $GITHUB_STEP_SUMMARY
        echo "| Docker Images | ‚úÖ Pushed to ECR | - |" >> $GITHUB_STEP_SUMMARY
        echo "| Health Checks | ‚úÖ Passed | - |" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        
        echo "### üîó Access Your MLOps Stack" >> $GITHUB_STEP_SUMMARY
        echo "1. **Get Node IP**: \`kubectl get nodes -o wide\`" >> $GITHUB_STEP_SUMMARY
        echo "2. **UI Interface**: \`http://NODE_IP:$UI_PORT\`" >> $GITHUB_STEP_SUMMARY
        echo "3. **API Health**: \`http://NODE_IP:$API_PORT/health\`" >> $GITHUB_STEP_SUMMARY
        echo "4. **API Documentation**: \`http://NODE_IP:$API_PORT/docs\`" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        
        echo "### üéØ What You Can Do Now" >> $GITHUB_STEP_SUMMARY
        echo "- **üîÆ Make Predictions**: Use the UI to predict customer churn" >> $GITHUB_STEP_SUMMARY
        echo "- **üìä Monitor Models**: Check model status in the UI" >> $GITHUB_STEP_SUMMARY
        echo "- **üß™ Test API**: Use the Swagger docs for API testing" >> $GITHUB_STEP_SUMMARY
        echo "- **üìà Track Experiments**: View MLflow at http://3.110.135.31:30418/" >> $GITHUB_STEP_SUMMARY
        echo "- **üîÑ Approve Models**: Manage models in SageMaker Registry" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        
        echo "### üõ†Ô∏è Troubleshooting" >> $GITHUB_STEP_SUMMARY
        echo "- **Check pods**: \`kubectl get pods\`" >> $GITHUB_STEP_SUMMARY
        echo "- **View logs**: \`kubectl logs -l app=churn-prediction-api\`" >> $GITHUB_STEP_SUMMARY
        echo "- **Port forward**: \`kubectl port-forward svc/churn-prediction-ui-service 3000:80\`" >> $GITHUB_STEP_SUMMARY
        echo "- **Model reload**: Use UI \"Reload Model\" button" >> $GITHUB_STEP_SUMMARY 